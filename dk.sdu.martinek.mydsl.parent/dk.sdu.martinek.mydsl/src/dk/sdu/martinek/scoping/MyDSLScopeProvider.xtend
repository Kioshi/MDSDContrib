/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.martinek.scoping

import dk.sdu.martinek.myDSL.impl.SpecificationImpl
import dk.sdu.martinek.myDSL.impl.WidgetImpl
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import dk.sdu.martinek.myDSL.MyDSLPackage
import dk.sdu.martinek.myDSL.Entity
import dk.sdu.martinek.myDSL.impl.ModelImpl
import dk.sdu.martinek.myDSL.impl.EntityImpl
import java.util.ArrayList
import dk.sdu.martinek.myDSL.Specification
import dk.sdu.martinek.myDSL.impl.AttributeImpl
import java.util.List
import dk.sdu.martinek.myDSL.Property
import dk.sdu.martinek.myDSL.impl.PropertyImpl
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.emf.ecore.InternalEObject
import dk.sdu.martinek.myDSL.Widget
import dk.sdu.martinek.myDSL.Attribute
import dk.sdu.martinek.myDSL.impl.MyEntityIdentifierImpl
import org.eclipse.xtext.scoping.impl.ImportUriGlobalScopeProvider
import java.util.LinkedHashSet
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider
import org.eclipse.xtext.scoping.impl.ImportNormalizer
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.impl.AliasedEObjectDescription
import org.eclipse.xtext.resource.EObjectDescription

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MyDSLScopeProvider extends AbstractMyDSLScopeProvider {

	//@Inject extension MyDSLModelUtils
	
	override IScope getScope(EObject context, EReference reference) {
		// Only suggest entities that are not defined yet
		if (context instanceof ModelImpl && reference == MyDSLPackage.Literals.SPECIFICATION__REF)
		{		
	        val rootElement = EcoreUtil2.getRootContainer(context)
	        val elements = EcoreUtil2.getAllContentsOfType(rootElement, Entity)
			val alreadyDefined = new ArrayList<Entity>()
			val entities = new ArrayList<Entity>()
			for(Specification specification : (context as ModelImpl).specifications.specifications)
			{
				val type = specification.ref
				alreadyDefined.add(type)
				
			}
			elements.forEach[itr| 				
				if(!alreadyDefined.contains(itr))
					entities.add(itr);
			]
			
			return Scopes.scopeFor(entities)
		}
		
		// All Entities allowed in specification
		if (context instanceof SpecificationImpl && reference == MyDSLPackage.Literals.SPECIFICATION__REF)
		{		
	        val rootElement = EcoreUtil2.getRootContainer(context)
	        val elements = EcoreUtil2.getAllContentsOfType(rootElement, Entity)
			return Scopes.scopeFor(elements)
		}
		
		if (context instanceof AttributeImpl && reference.containerClass == Attribute)
		{
	        return Scopes.scopeFor(((((context as AttributeImpl).eContainer as SpecificationImpl).ref as EntityImpl).ref as WidgetImpl).properties)			
		}
		
		// Add possible properties to specification
		// Note - filtering by already added is not possible since context.attributes..property is unresolvable proxy
		if (context instanceof SpecificationImpl && reference == MyDSLPackage.Literals.ATTRIBUTE__REF)
		{		
	       
			val entity = (context as SpecificationImpl).ref
			
			val widget = entity.ref
			if (widget instanceof WidgetImpl)
			{
				return Scopes.scopeFor(widget.properties)
			}
			return IScope.NULLSCOPE
		}
		
		// Attribute entities
		if (context instanceof MyEntityIdentifierImpl && reference == MyDSLPackage.Literals.MY_ENTITY_IDENTIFIER__REF)
		{
	        val rootElement = EcoreUtil2.getRootContainer(context)
	        val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Entity)
			val elements = new ArrayList<EObject>()
			//elements.addAll(super.getScope(context, reference).allElements.map[itr | itr.EObjectOrProxy])
			elements.addAll(candidates);
			//candidates.addAll(elements.filter[itr | itr instanceof Entity].map[itr | itr as Entity])
			//System.out.println(elements)
			val s2 = super.getScope(context, reference)
			val s1 = Scopes.scopeFor(elements, s2)//super.getScope(context, reference)
			System.out.println(s1)
			System.out.println(s2)
			return s1
			/*
	        val allElements = super.getScope(context, reference).allElements
	        val elements = new ArrayList<Entity>()
	        allElements.forEach[itr| 
	        	switch(itr)
	        	{
	        		
	        		AliasedEObjectDescription: elements.add(itr.EObjectOrProxy as Entity)// .delegate.element)//System.out.println("a")	
	        		EObjectDescription: System.out.println("b")	
	        		default: elements.add(itr.EObjectOrProxy as Entity)
	        	}       	
	        ]
        	System.out.println(elements)	
	        return Scopes.scopeFor(elements)//super.getScope(context, reference)
	        val allElements = super.getScope(context, reference).allElements
	        var elements = new ArrayList<Entity>()
	        allElements.forEach[itr|
	        	System.out.println(itr + " " +itr.class.getName())	 
	        	switch(itr)
	        	{
	        		
	        		AliasedEObjectDescription: System.out.println("a")	
	        		EObjectDescription: System.out.println("b")	
	        		default: System.out.println("c")
	        	}       	
	        ]
	        val rootElement = EcoreUtil2.getRootContainer(context)
	        val entities = EcoreUtil2.getAllContentsOfType(rootElement, Entity)
	        System.out.println(entities)
	        return Scopes.scopeFor(entities)
	        */
		}
		
		// Layout entitites - no need to modify scope
		if (context instanceof EntityImpl && reference == MyDSLPackage.Literals.ENTITY__REF)
		{	
			return super.getScope(context, reference)
		}
		
		// Attribute entities suggestions
		if (context instanceof AttributeImpl && reference == MyDSLPackage.Literals.MY_ENTITY_IDENTIFIER__REF)
		{
			return Scopes.scopeFor(super.getScope(context, reference).allElements.map[itr | itr.EObjectOrProxy])//super.getScope(context, reference)
			/*
	        val allElements = super.getScope(context, reference).allElements
	        val elements = new ArrayList<Entity>()
	        allElements.forEach[itr| 
	        	switch(itr)
	        	{
	        		
	        		AliasedEObjectDescription: elements.add(itr.EObjectOrProxy as Entity)// .delegate.element)//System.out.println("a")	
	        		EObjectDescription: System.out.println("b")	
	        		default: elements.add(itr.EObjectOrProxy as Entity)
	        	}       	
	        ]
        	System.out.println(elements)	
	        return Scopes.scopeFor(elements)//super.getScope(context, reference)
	        */
		}
	
		super.getScope(context, reference)
	}
	/*
	 
		if (context instanceof SpecificationImpl)
		{
			container = context
		}
		else if (context instanceof AttributeImpl)
		{
			container = context.eContainer;
			if (reference.EReferenceType.instanceClass == Entity)
			{				
		        val rootElement = EcoreUtil2.getRootContainer(context)
		        val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Entity)
		        if (container instanceof SpecificationImpl)
		        {
		        	candidates.remove(container.type)
		        }

		        return Scopes.scopeFor(candidates)
			}
		}
		
		if (container instanceof SpecificationImpl)
		{
	        val rootElement = EcoreUtil2.getRootContainer(context)
	        val candidates = new ArrayList<EObject>()
	        candidates.addAll(EcoreUtil2.getAllContentsOfType(rootElement, EntityIdentifier))
			val entity = container.type
			if (entity instanceof ChildlessEntityImpl)
			{
				val widget = entity.type
				if (widget instanceof WidgetImpl)
				{
	        		candidates.addAll(widget.properties)
					return Scopes.scopeFor(candidates)
				}					
			}
			if (entity instanceof ChildfullEntityImpl)
			{
				val widget = entity.type
				if (widget instanceof WidgetImpl)
				{
					return Scopes.scopeFor(widget.properties)
				}
			}
		}
		
	 */
	
}
