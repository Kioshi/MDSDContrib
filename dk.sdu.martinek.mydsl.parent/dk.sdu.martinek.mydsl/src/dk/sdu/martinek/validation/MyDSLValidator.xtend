/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.martinek.validation

import dk.sdu.martinek.myDSL.Attribute
import dk.sdu.martinek.myDSL.Entity
import dk.sdu.martinek.myDSL.Layout
import dk.sdu.martinek.myDSL.MyEntityIdentifier
import dk.sdu.martinek.myDSL.Property
import dk.sdu.martinek.myDSL.Widget
import java.util.ArrayList
import java.util.List
import java.util.regex.Pattern
import java.util.stream.Collectors
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import dk.sdu.martinek.myDSL.Header
import java.io.File
import dk.sdu.martinek.myDSL.Entities
import dk.sdu.martinek.myDSL.Specifications
import java.util.Collections
import dk.sdu.martinek.myDSL.Widgets

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDSLValidator extends AbstractMyDSLValidator {
		
	public static val BODY_PROPERTY = "__BODY__"
	public static val ID_PROPERTY = "__ID__"
	
	
	public static val INVALID_NAME = 'invalidName'

	@Check
	def checkWidgetDuplicates(Widget element) {
		val propetiesGrouped = element.properties.groupBy[e|e?.eGet(e?.eClass?.getEStructuralFeature("name"))]
		val propertiesDuplicated = propetiesGrouped.filter[p1, p2|p2.length>1]
		val onlytheEObjects = propertiesDuplicated.values().stream().flatMap(e|e.stream).collect(
			Collectors.toList())
		onlytheEObjects.forEach [ e |
			val nameRef = e?.eClass?.getEStructuralFeature("name")
			val nameAttr = e?.eGet(nameRef)

			error('Duplicate name ' + nameAttr + " for " + e.eClass.name,e, nameRef, INVALID_NAME)
		]
	}
	
	public static val MISSING_PROPERTIES = 'missingProperties'
	public static val UNUSED_PROPERTIES = 'unusedProperties'
	
	@Check
	def checkWidgetTemplate(Widget element) {
		val pattern = Pattern.compile("(%)([a-zA-Z]+?)(%)");
        val matcher = pattern.matcher(element.template.value);

        val  listMatches = new ArrayList<String>();

        while(matcher.find())
        {
            listMatches.add(matcher.group(2));
        }
        
        val missingProperties = new ArrayList<String>()
        element.properties.forEach[ property |
        	if (!listMatches.contains(property.name))
        	error('Property ' + property.name + " is unused in template", property, property.eClass.getEStructuralFeature("name"), UNUSED_PROPERTIES)
        ]
       
        listMatches.forEach[ match |
        	if (!element.properties.stream().map(e| e.name).collect(
				Collectors.toList()).contains(match))
        		missingProperties.add(match)        		
        ]
        
        if (!missingProperties.empty)
        {
        	if (missingProperties.size > 1)
        		error('Properties ' + missingProperties.stream().collect( Collectors.joining( "," ) ) + " are not defined in Widget", element.template, null, MISSING_PROPERTIES)
    		else
        		error('Property ' + missingProperties.get(0) + " is not defined in Widget", element.template, null, "missingBody")
        }
		
	}
	
	@Check
	def checkPropertyForReservedName(Property property)
	{
		switch(property.name)
		{
			case BODY_PROPERTY,
			case ID_PROPERTY:
				error(property.name + " is namer reserved for internal purposes and should not be used as property", property, null, "reservedName")
		}
	}
	
	@Check
	def checkIfEntityCanHaveChild(Layout layout) 
	{
		if (!layout.childs.empty)
		{
			val pattern = Pattern.compile(BODY_PROPERTY);
			val entity = layout.ref
	        val matcher = pattern.matcher(entity.ref.template.value);
	
			if (!matcher.find())
				error('Layout ' + entity.name + " can not have childs since its Widget ("+ entity.ref.name +") template dont have defined '"+BODY_PROPERTY+"' in its template", layout, null, MISSING_PROPERTIES)	
		}
	}
	
	@Check
	def checkIfEntityHaveProperties(Entity entity)
	{
		getListOfMissingAttributes(entity).forEach[str|
			error(str, entity, null, "missinAttribute")			
		]
	}
	
	def List<String> getListOfMissingAttributes(Entity entity)
	{
		var list = newArrayList()
		for (Property prop : entity.ref.properties)
		{
			if (prop.defaultValue === null)
			{
				val attrProp = entity.attributes.findFirst[itr|
					return (itr as Attribute).ref == prop
				]
				
				if (attrProp === null)
				{
					if (entity.parent === null || entity.parent.attributes.findFirst[itr|(itr as Attribute).ref == prop] === null)
					{
						list.add('Attribute ' + prop.name + " is mising in element definition")
					}
				}
			}			
		}
		return list		
	}
	
	def String isComplete(Entity current, List<Entity> previous)
	{
        //EcoreUtil2.resolveAll(current)
		if (previous.contains(current))
		{
			return "Cyclic reference: " + current.name + " was already referenced before - "+ previous.map[itr| itr.name].toString
		}
		previous.add(current)
		
		if (!getListOfMissingAttributes(current).empty)
		{
			return "Element " + current.name + " missing attribute definitions"
		}
		
		// Check parrent
		if (current.parent !== null)
		{
			val res = isComplete(current.parent, previous)
			if (res !== null)
			{
				return "Parent of element " + current.name +" causing error: "+ res;				
			}
		}
		
        val entities = EcoreUtil2.getAllContentsOfType(current, MyEntityIdentifier)
        for (MyEntityIdentifier entity : entities)
        {
        	val res = isComplete(entity.ref, previous)
    		if (res !== null)
    		{
    			return "Element "+current.name+" - attribute element "+ entity.ref.name + " error: " + res 
    		}        	
        }
		return null
	}
	
	@Check
	def checkIfAttributeValueEntityIsComplete(Attribute attribute) 
	{
		val value = attribute.right
		if (value instanceof MyEntityIdentifier)
		{
			val res = isComplete(value.ref as Entity, newArrayList(attribute.eContainer as Entity))
			if (res !== null)
			{
				error(res, attribute, null, "entityReferenceError")
			}
		}
	}
	
	
	@Check
	def checkIfParentEntityIsComplete(Entity entity) 
	{
		if (entity.parent !== null)
		{
			val res = isComplete(entity.parent, newArrayList(entity))
			if (res !== null)
			{
				error(res, entity, null, "entityReferenceError")
			}
		}
	}
	
	@Check 
	def checkIfParentHasSameWidget(Entity entity)
	{
		if (entity.parent !== null && entity.ref != entity.parent.ref)
		{
			error("Parent have to be same type (widget) as element!", entity, null, "entityParentType")			
		}
	}
	
	@Check
	def checkIfHeaderFileExists(Header header)
	{
		if (header.type == "custom")
		{
			return
		}
		
		val file = new File(header.value)
		if (!file.exists)
		{
			error("File "+header.value+" not found!", header, null, "headerFileNotFound")
		}
	}
	
	@Check
	def checkIfEntityNameIsUnique(Specifications entities)
	{
		for (Entity entity :  entities.entities)
		{
			if (Collections.frequency(entities.entities.map[itr| itr.name], entity.name) > 1)
			{
				error("Entity name "+entity.name+" is not unique!", entity, null, "entityNameNotUnique")
			}
		}
	}
	
	@Check
	def checkIfWidgetNameIsUnique(Widgets widgets)
	{
		for (Widget widget :  widgets.widgets)
		{
			if (Collections.frequency(widgets.widgets.map[itr| itr.name], widget.name) > 1)
			{
				error("Widget name "+widget.name+" is not unique!", widget, null, "widgetNameNotUnique")
			}
		}
	}
}
